"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[602],{89318:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>d,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"notes","title":"Special Notes","description":"No bare code in modules with cyclic dependencies","source":"@site/docs/notes.md","sourceDirName":".","slug":"/notes","permalink":"/order/docs/notes","draft":false,"unlisted":false,"editUrl":"https://github.com/michaeldougal/framework/edit/master/docs/notes.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Special Notes"},"sidebar":"defaultSidebar","previous":{"title":"Usage","permalink":"/order/docs/setup"},"next":{"title":"Contributions","permalink":"/order/docs/contributions"}}');var i=n(74848),s=n(28453);const r={sidebar_position:4,title:"Special Notes"},d="Special Notes",a={},c=[{value:"No bare code in modules with cyclic dependencies",id:"no-bare-code-in-modules-with-cyclic-dependencies",level:2},{value:"Loading modules with non-unique names",id:"loading-modules-with-non-unique-names",level:2},{value:"Printing module tables",id:"printing-module-tables",level:2}];function l(e){const t={h1:"h1",h2:"h2",header:"header",p:"p",strong:"strong",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"special-notes",children:"Special Notes"})}),"\n",(0,i.jsx)(t.h2,{id:"no-bare-code-in-modules-with-cyclic-dependencies",children:"No bare code in modules with cyclic dependencies"}),"\n",(0,i.jsxs)(t.p,{children:["In order to support cyclic dependencies, it must be guaranteed that the module in question has ",(0,i.jsx)(t.strong,{children:"no bare code that references a cyclic dependency"}),". That is to say that any code that references the cyclic dependency must be contained within a function. If Order detects this bare code, you will be notified with a warning in the output and no operation will be processed on the module in question."]}),"\n",(0,i.jsx)(t.h2,{id:"loading-modules-with-non-unique-names",children:"Loading modules with non-unique names"}),"\n",(0,i.jsx)(t.p,{children:"Modules can be specified through several different paths. If the name is unique, you can reference it simply through that. If two modules exist with the same name however, Order will warn you that it found two or more possible modules for your request, and will ask you to be more specific. You can use any level of the module paths it provides you with, as long as they're unique as well."}),"\n",(0,i.jsxs)(t.p,{children:["Order does not index all potential file paths by default, so it is recommended to use the ",(0,i.jsx)(t.strong,{children:"shortest unique paths possible"})," in order to conserve memory usage."]}),"\n",(0,i.jsx)(t.h2,{id:"printing-module-tables",children:"Printing module tables"}),"\n",(0,i.jsx)(t.p,{children:"One of the complications with the method Order uses to support cyclic dependencies is that if you try to print out one of these module's tables, it would return a table address instead of an output-friendly table. In order to preserve as much functionality as possible, Order will list out table keys and values in a custom format when converting the table to a string."})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>d});var o=n(96540);const i={},s=o.createContext(i);function r(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);